#ifndef INCLUDED_VECTOR_4_HPP
#define INCLUDED_VECTOR_4_HPP

#include <ostream>

#include "Vector3.hpp"

namespace zeno {

////////////////////////////////////////////////////////////
//
//	Template class for 4D Vector4s
//
////////////////////////////////////////////////////////////
template <typename T>
class Vector4
{
public:
	////////////////////////////////////////////////////////////
	//
	//	Default constructor, initialises x and y and z and w 
	//	to zero
	//
	////////////////////////////////////////////////////////////
	Vector4();

	////////////////////////////////////////////////////////////
	//
	//	Initialises x and y and z and w to the given values
	//
	////////////////////////////////////////////////////////////
	Vector4(T _x, T _y, T _z, T _w);

	////////////////////////////////////////////////////////////
	//
	//	Copy constructor, initialises x and y and z and w 
	//	to the same values the _vec has
	//
	////////////////////////////////////////////////////////////
	template <typename U>
	Vector4(const Vector4<U>& _vec);

	////////////////////////////////////////////////////////////
	//
	//	Copy constructor, initialises x and y and z
	//	to the same values the _vec has, and sets w to _w
	//
	////////////////////////////////////////////////////////////
	Vector4(const Vector3<T>& _vec, T _w);

public:
	////////////////////////////////////////////////////////////
	//
	//	Member variable, x coordinate
	//
	////////////////////////////////////////////////////////////
	T x;
	////////////////////////////////////////////////////////////
	//
	//	Member variable, y coordinate
	//	
	////////////////////////////////////////////////////////////
	T y;
	////////////////////////////////////////////////////////////
	//
	//	Member variable, z coordinate
	//	
	////////////////////////////////////////////////////////////
	T z;
	////////////////////////////////////////////////////////////
	//
	//	Member variable, w coordinate
	//	
	////////////////////////////////////////////////////////////
	T w;
};

////////////////////////////////////////////////////////////
//
//	Overload of - operator
//	returns negated vector
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T> operator -(const Vector4<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of -= operator
//	Modifies _left by subtracting _right from it
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T>& operator -=(Vector4<T>& _left, const Vector4<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of - operator
//	returns subtraction of _right from _left
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T> operator -(const Vector4<T>& _left, const Vector4<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overlaod of += operator
//	Modifies _left by adding _right to it
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T> operator +=(Vector4<T>& _left, const Vector4<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of + operator
//	returns addition of _left and _right
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T> operator +(const Vector4<T>& _left, const Vector4<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of /= operator
//	Modifies _left by dividing by _right per value
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T>& operator /=(Vector4<T>& _left, T _right);

////////////////////////////////////////////////////////////
//
//	Overload of / operator
//	returns component wise division of _left by _right
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T> operator /(const Vector4<T>& _left, T _right);

////////////////////////////////////////////////////////////
//
//	Overload of *= operator
//	modifies _left by multiplying by _right per value
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T> operator *=(Vector4<T>& _left, T _right);

////////////////////////////////////////////////////////////
//
//	Overload of * operator
//	returns component wise multiplication of _left by _right
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T> operator *(const Vector4<T>& _left, T _right);

////////////////////////////////////////////////////////////
//
//	Overload of * operator
//	returns component wise multiplication of _right by _left
//
////////////////////////////////////////////////////////////
template <typename T>
Vector4<T> operator *(T _left, const Vector4<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of == operator
//	returns boolean on whether the components of both
//	vectors are the same (no tolerance)
//
////////////////////////////////////////////////////////////
template <typename T>
bool operator ==(const Vector4<T>& _left, const Vector4<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of != operator
//	returns boolean on whether the components of both
//	vectors are not the same (no tolerance)
//
////////////////////////////////////////////////////////////
template <typename T>
bool operator !=(const Vector4<T>& _left, const Vector4<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of << operator for std::ostream
//
////////////////////////////////////////////////////////////
template <typename T>
std::ostream& operator <<(std::ostream& os, zeno::Vector4<T> const& _vec);




#include "Vector4.inl"

typedef Vector4<int>				Vector4i;
typedef Vector4<unsigned int>		Vector4u;
typedef Vector4<float>				Vector4f;
typedef Vector4<double>				Vector4d;

} //~ namespace zeno

#endif //~ INCLUDED_VECTOR_4_HPP
