#ifndef INCLUDED_ZENO_SYSTEM_VECTOR_3_HPP
#define INCLUDED_ZENO_SYSTEM_VECTOR_3_HPP

#include <ostream>

#include <cmath>

////////////////////////////////////////////////////////////
///
///	\namespace zeno
///
////////////////////////////////////////////////////////////
namespace zeno {

////////////////////////////////////////////////////////////
///
///	\brief	Template class for 3D Vectors
///
////////////////////////////////////////////////////////////
template <typename T>
class Vector3
{
public:
	////////////////////////////////////////////////////////////
	///
	///	\brief	Default constructor
	///
	///	Creates a Vector3 with x, y and z equal to 0
	///
	////////////////////////////////////////////////////////////
	Vector3();

	////////////////////////////////////////////////////////////
	///
	///	\brief	Initialises x, y and z to the given values
	///
	///	\param	_x		value that x is set to
	///
	///	\param	_y		value that y is set to
	///
	///	\param	_z		value that z is set to
	///
	////////////////////////////////////////////////////////////
	Vector3(T _x, T _y, T _z);

	////////////////////////////////////////////////////////////
	///
	///	\brief	Copy constructor
	///
	///	Initialises the vector to have the same values as that
	///	of the parameter 
	///
	///	\param	_vec	Vector3 that is used to initialise this
	///					Vector3
	///
	////////////////////////////////////////////////////////////
	template <typename U>
	Vector3(const Vector3<U>& _vec);

public:
	T x;	///<	x component

	T y;	///<	y component

	T z;	///<	z component
};

////////////////////////////////////////////////////////////
///
///	\relates	zeno::Vector3
///
///	\brief		Overload of negate operator
///
///	\param		_right		Vector3 to negate
///
///	\return		Component-wise negated version of the Vector3
///
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T> operator -(const Vector3<T>& _right);

////////////////////////////////////////////////////////////
///
///	\relates	zeno::Vector3
///
///	\brief		Overload of minus-equals operator
///
///	\param		_left		Vector3 to be modified
///
///	\param		_right		Vector3 to subtract
///
///	\return		Reference to \a _left Vector3
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T>& operator -=(Vector3<T>& _left, const Vector3<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of - operator
//	returns subtraction of _right from _left
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T> operator -(const Vector3<T>& _left, const Vector3<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overlaod of += operator
//	Modifies _left by adding _right to it
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T> operator +=(Vector3<T>& _left, const Vector3<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of + operator
//	returns addition of _left and _right
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T> operator +(const Vector3<T>& _left, const Vector3<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of /= operator
//	Modifies _left by dividing by _right per value
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T>& operator /=(Vector3<T>& _left, T _right);

////////////////////////////////////////////////////////////
//
//	Overload of / operator
//	returns component wise division of _left by _right
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T> operator /(const Vector3<T>& _left, T _right);

////////////////////////////////////////////////////////////
//
//	Overload of *= operator
//	modifies _left by multiplying by _right per value
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T> operator *=(Vector3<T>& _left, T _right);

////////////////////////////////////////////////////////////
//
//	Overload of * operator
//	returns component wise multiplication of _left by _right
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T> operator *(const Vector3<T>& _left, T _right);

////////////////////////////////////////////////////////////
//
//	Overload of * operator
//	returns component wise multiplication of _right by _left
//
////////////////////////////////////////////////////////////
template <typename T>
Vector3<T> operator *(T _left, const Vector3<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of == operator
//	returns boolean on whether the components of both
//	vectors are the same (no tolerance)
//
////////////////////////////////////////////////////////////
template <typename T>
bool operator ==(const Vector3<T>& _left, const Vector3<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of != operator
//	returns boolean on whether the components of both
//	vectors are not the same (no tolerance)
//
////////////////////////////////////////////////////////////
template <typename T>
bool operator !=(const Vector3<T>& _left, const Vector3<T>& _right);

////////////////////////////////////////////////////////////
//
//	Overload of << operator for std::ostream
//
////////////////////////////////////////////////////////////
template <typename T>
std::ostream& operator <<(std::ostream& os, zeno::Vector3<T> const& _vec);




#include "Vector3.inl"

typedef Vector3<int>				Vector3i;
typedef Vector3<unsigned int>			Vector3u;
typedef Vector3<float>				Vector3f;
typedef Vector3<double>				Vector3d;

} //~ namespace zeno

#endif //~ INCLUDED_ZENO_SYSTEM_VECTOR_3_HPP
