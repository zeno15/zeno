#ifndef INCLUDED_SHADER_HPP
#define INCLUDED_SHADER_HPP

#include <string>
#include <vector>

#include <Vector3.hpp>
#include <Mat4x4.hpp>

namespace zeno {

////////////////////////////////////////////////////////////
//
//	OpenGL Shader class
//
////////////////////////////////////////////////////////////
class Shader
{
public:
	////////////////////////////////////////////////////////////
	//
	//	Default constructor
	//
	////////////////////////////////////////////////////////////
	Shader(void);
	////////////////////////////////////////////////////////////
	//
	//	Constructor which takes the paths to the shaders files
	//
	////////////////////////////////////////////////////////////
	Shader(const std::string& _vertexPath, const std::string& _fragmentPath);
	////////////////////////////////////////////////////////////
	//
	//	Deconstructor, deketes the shader program
	//
	////////////////////////////////////////////////////////////
	~Shader(void);

	////////////////////////////////////////////////////////////
	//
	//	Loads the vertex shader from its file
	//
	////////////////////////////////////////////////////////////
	void loadVertexShader(const std::string& _vertexPath);
	////////////////////////////////////////////////////////////
	//
	//	Loads the fragment shader from its file
	//
	////////////////////////////////////////////////////////////
	void loadFragmentShader(const std::string& _fragmentPath);
	////////////////////////////////////////////////////////////
	//
	//	Loads both shaders from their files
	//
	////////////////////////////////////////////////////////////
	void loadShaders(const std::string& _vertexPath, const std::string& _fragmentPath);
	////////////////////////////////////////////////////////////
	//
	//	Loads both shaders from the given strings
	//
	////////////////////////////////////////////////////////////
	void loadShadersFromStrings(const std::string& _vertexSource, const std::string& _fragmentSource);

	////////////////////////////////////////////////////////////
	//
	//	Returns whether or not the shaders compile successfully
	//
	////////////////////////////////////////////////////////////
	bool compileShader(void);
	////////////////////////////////////////////////////////////
	//
	//	Used to get the compilation error if compileShader 
	//	returns false
	//
	////////////////////////////////////////////////////////////
	std::string getCompileError(void);

	////////////////////////////////////////////////////////////
	//
	//	Binds the shader for rendering use
	//
	////////////////////////////////////////////////////////////
	void bind(void);
	////////////////////////////////////////////////////////////
	//
	//	Unbinds the currently bound shader
	//
	////////////////////////////////////////////////////////////
	static void unbind(void);

	////////////////////////////////////////////////////////////
	//
	//	Gets the program Id
	//
	////////////////////////////////////////////////////////////
	unsigned int getId(void);

	////////////////////////////////////////////////////////////
	//
	//	Returns whether or not the given uniform is found within
	//	the shader
	//
	////////////////////////////////////////////////////////////
	bool getLocationOfUniform(const std::string& _uniform);
	////////////////////////////////////////////////////////////
	//
	//	Passes the uniform with the given name of type Vector3
	//	to the shader
	//
	////////////////////////////////////////////////////////////
	void passUniform(const std::string& _name, const Vector3<float>& _uniform);
	////////////////////////////////////////////////////////////
	//
	//	Passes the uniform with the given name of type Mat4x4
	//	to the shader
	//
	////////////////////////////////////////////////////////////
	void passUniform(const std::string& _name, const Mat4x4& _uniform);
	
private:
	////////////////////////////////////////////////////////////
	//
	//	Stores the error associated with the last compilation
	//
	////////////////////////////////////////////////////////////
	std::string m_Error;

	////////////////////////////////////////////////////////////
	//
	//	Contains the vertex shader
	//
	////////////////////////////////////////////////////////////
	std::string m_VertexShaderSource;
	////////////////////////////////////////////////////////////
	//
	//	Contains the fragment shader
	//
	////////////////////////////////////////////////////////////
	std::string m_FragmentShaderSource;

	////////////////////////////////////////////////////////////
	//
	//	The shader program id
	//
	////////////////////////////////////////////////////////////
	unsigned int m_ProgramId;

	////////////////////////////////////////////////////////////
	//
	//	Vector of uniforms and their locations
	//
	////////////////////////////////////////////////////////////
	std::vector<std::pair<std::string, int>>		m_UniformLocations;
};

} //~ namespace zeno

#endif //~ INCLUDED_SHADER_HPP
